## Hash에 대한 정리

<br>

- #### Hash에 대해 설명해주세요.
  
  Hash는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖습니다. (O(1))

  그리고 데이터 추가/삭제 시 기존 데이터를 밀어내거나 당기는 작업이 필요없도록 hashCode() 메소드를 이용하여 데이터와 연관된 고유한 숫자를 만들어낸 뒤 이를 인덱스로 사용합니다. (O(1))

  Java에서는 Object 클래스의 hashCode() 메소드를 이용하여 모든 객체의 HashCode를 쉽게 구할 수 있습니다. 

  Hash Method를 이용해서 데이터를 Hash Table에 저장하고 검색하는 기법을 **Hashing**이라고 합니다.

<br>

- #### 그렇다면 hashCode()를 통해 같은 key값을 갖게 되는 경우가 발생할 경우 어떻게 처리되나요? - Hash Collision에 대한 질문

  Hash Collision 방법은 2가지 존재합니다.

  1) 개방 주소법 (Open Addressing)
  충돌이 발생했을 시 다른 주소에 저장하는 기법입니다.

  - Linear Probing (선형 탐사법)
    충돌 발생 시 주소를 하나씩 이동하면서 탐사하는 방법
  - Quadratic Probing (제곱 탐사법)
    충돌 발생 시 주소를 제곱으로 늘어나면서 탐사하는 방법 (1, 4, 9, 16, ...)
  - Double Hashing (이중 해싱)
     원래 해시 함수와 다른 보조 해시 함수를 이용하는 방법입니다. 이중 해싱법은 충돌의 발생 가능성은 가장 적으나, 캐시의 성능은 Linear Probing, Quadratic Probing과 비교했을 때 가장 좋지 않으며, 추가적인 해시 연산이 들어가기에 가장 많은 연산량을 요구한다는 단점이 있습니다.

  2) 분리 연결법 (Seperate Chaining)
  값을 연결리스트 형태로 저장하는 걸 의미합니다. 해시 충돌이 일어나더라도 리스트로 노드가 연결되기 때문에 index가 변하지 않고 데이터 개수의 제약이 없다는 장점이 있습니다. 반면, open addressing 방법과 비교했을 때 추가적인 메모리 공간이 필요하며, 테이블의 적재율(Load Factor)에 따라 선형적으로 성능이 저하됩니다.

<br>

- #### Java의 HashMap은 어떻게 동작하나요?

  Java7까지의 HashMap은 Seperate Chaining를 채택하며 링크드 리스트를 고정적으로 사용했지만 Java 8 이후부터는 데이터의 개수가 많아지면 트리를 사용하도록 변경되었습니다. 링크드 리스트를 사용했을 때는 조회에 대한 시간복잡도가 O(N/M)을 보여줬지만 트리를 사용하게 되면 O(log N/M)의 복잡도를 가지게 됩니다. 
  
  ```Java
  static final int TREEIFY_THRESHOLD = 8;

  static final int UNTREEIFY_THRESHOLD = 6;
  ```

  Java8 HashMap에서는 상수 형태로 기준을 정하고 있습니다. 즉 하나의 해쉬 버킷에 8개의 키-값 쌍이 모이면 링크드 리스트를 트리로 변경합니다. 만약 데이터를 삭제하여 6새에 이르면 다시 링크드 리스트로 변경하는데, 트리는 링크드 리스트보다 메모리 사용량이 많고,  데이터의 개수가 적을 때 트리와 링크드 리스트의 Worst Case 수행 시간 차이 비교는 의미가 없기 때문입니다. 8과 6으로 2 이상의 차이를 둔 것은, 만약 차이가 1이라면 어떤 한 키-값 쌍이 반복되어 삽입/삭제되는 경우 불필요하게 트리와 링크드 리스트를 변경하는 일이 반복되어 성능 저하가 발생할 수 있기 때문입니다. 이때 사용하는 트리는 Red-Black Tree입니다.

<br>

- #### Java에서 HashMap의 최대 Size는 어떻게 되나요?

  버킷의 최대 개수는 2^30개 (Integer 값 최대 범위의 절반)입니다.

<br>